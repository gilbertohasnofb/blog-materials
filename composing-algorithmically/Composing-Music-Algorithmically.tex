\documentclass{article}

\usepackage{color}

\usepackage[a4paper, top=2.5cm, bottom=2.5cm, left=2.5cm, right=2.5cm]{geometry}

\usepackage{pdfpages}

\begin{document}
\title{Composing Music Algorithmically}
\author{Gilberto Agostinho}
\date{}
\maketitle

As pointed out in previous posts by Urs Liska \textcolor{red}{[links to "Plain Text Files in Music" and "Programmatically Generating LilyPond Input"]}, a music engraving program that is based on plain text has the potential to be programmatically controlled by the user, which is a big attractive for an algorithmic composer such as myself. 
There are numerous ways of manipulating plain text files, and this can be done by using virtually any programming language one might know. 
In the case of LilyPond, it is possible to programatically write a score by directly inputting a mixture of regular LilyPond code and code written in its extension language, Scheme; another popular choice is to use Python, together with dedicated packages such as Abjad \textcolor{red}{[link to its website]}. 
On my case though, I have chosen to do all my work using Fortran 95. \\

I use Fortran for a very simple reason: before studying music, I studied physics for a couple of years, where all my programming projects had to be written in Fortran. 
Even with all its limitation, I still see Fortran as a very powerful language, particularly when dealing with pure mathematical calculations (something that I use constantly on my compositions). 
And then, during the last months, I have been writing a library of subroutines for Fortran which works as a LilyPond parser 
\textcolor{red}{[is parser the correct word? sorry but I lack basic terminology of programming. I meant that my library works as a sort of "translator" from Fortran into LilyPond]}, allowing me to algorithmically generate a .LY file. \\

Due to both my wish to experiment with my library and my interest in gradual processes in music, I decided to implement Steve Reich's \textit{Clapping Music} \textcolor{red}{[link to some performance at Youtube maybe?!]}. 
For those whom are not familiar with this composition, it follows a very simple algorithm: take a pattern of claps and rests of length $N$ (in eighth notes). 
Player 1 will play this pattern in its original form for $N^2+N$ times. 
Player 2 will play the original pattern for $N$ times; after this, the pattern will have all its notes shifted by $-1$ beat (i.e., all notes move one beat to the left, and the first note becomes the last) and then it will be repeated for another $N$ times; 
after this, the current pattern will once again shift by $-1$ beat and be repeated for another $N$ times. 
This process is repeated until the two patterns coincide once again, when they are repeated for another $N$ times before ending the work (in principle, this procedure is somehow similar to Reich's ideas of playing a same melody at different speeds, applied in works such as \textit{Piano Phases}). \\

It is very important to note that Reich's composition consists of a single score with a specific chosen pattern: \\

\includegraphics{ClappingMusicSmall.pdf} \\

Therefore, he did not authored the process behind it, but rather its specific musical result. 
This is a very important distinction to make; compare this to \textit{I Am Sitting in a Room} \textcolor{red}{[link to Youtube once again?]}, by Alvin Lucier. 
In this work, Lucier blurs the difference between a \textit{composition} and a \textit{process} by allowing the interpreter to read out loud any text in any room (so, unlike Reich, he does not authors a specific \textit{pattern}). \\

While implementing Reich's score with his own pattern, I thought that it could be interesting to generalize his algorithm, so that the user could input any  pattern of claps and rests, of any length, and get his score automatically generated in front of him. 
The result of this little experiment is the present program I wrote. 
In pseudo code (Fortran style), Reich's algorithm looks like this: \\

\begin{verbatim}
read N ! input of the number of eighth notes per bar
do i=1,N
  read pattern(i) ! input of a pattern, using 1 as clap and 0 as rest
enddo

! Code for player 1
do i=1,(N+1)
  do j=1,N
    if (pattern(aux)==1) clap
    if (pattern(aux)==0) rest
  enddo
enddo

! code for player 2
do i=1,(N+1)
  do j=1,N

    ! shift of positions
    aux=MOD((j+i-1),N)
    if (aux==0) aux=N

    if (pattern(aux)==1) clap
    if (pattern(aux)==0) rest

  enddo
enddo
\end{verbatim}

Here is an example of a score generated by my program with a pattern of 5 notes ($N=5$). 
The pattern used is clap, clap, rest, clap, rest (or 11010 in binary notation, considering claps as 1 and rests as 0). \\

\includegraphics{Ex1Small.pdf} \\

\textcolor{red}{[would it be possible to add a link for the complete .PDF file and its .LY code here?! I think that could be interesting for the readers]} \\

Compare this previous example to another one, this time with the pattern 100110110 ($N=9$). \\

\includegraphics{Ex2Small.pdf} \\

\textcolor{red}{[another link for the .PDF and .LY files]} \\

I then decided to add still one more option to my program: to produce a random score, with a random $N$ varying between 3 and 15 and with a random pattern. 
Here is an example of it: \\

\includegraphics{Ex3Small.pdf} \\

\textcolor{red}{[and still another link for the .PDF and .LY files]} \\

This is just a very simple example of what can be done via programming and LilyPond. 
As a more complex example, consider that if Pierre Boulez had been stricter with his \textit{Structures Ia}, for two pianos (particularly with his lack of control over the registers), this composition could also have be generated algorithmically (and better still: it could also have been generalized for any series of $N$ sounds!). 
My own work as a composer is based on this concept of a generalized algorithm: 
having been influenced by the automation of the integral serialism, by Iannis Xenakis' use of probability and computers (mainly as a calculator on his case) and by composers that think of music as a process (such as Steve Reich and also the spectral composers), nowadays I consider that the act of composing cannot be distinguished from the act of creating and organizing generative musical procedures. 
It is as if one would create the laws that governs a hypothetical world, and then let this world evolute by itself (with the help of stochastic events, for instance). 
Lately, my main interest is to produce music that renews itself at every performance, be it electronic, be it acoustic. 
Using LilyPond together with Fortran has just allowed me that. \\

I would like to finish this short text by quoting Brian Eno: \\

\textit{I really think it is possible that our grandchildren will look at us in wonder and say: "You mean you used to listen to exactly the same thing over and over again?"}

\end{document} 